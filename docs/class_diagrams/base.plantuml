@startuml class_diagram_base
title Class diagram: Game, State and Move

hide empty members

!function $type($name)
!return "struct " + $name + " << (T,lavender) >>"
!endfunction

!function $type($name, $generics)
!return "struct " + $name + $generics + " << (T,lavender) >>"
!endfunction

!$M = "<M extends Move>"
!$G = "<G extends Game<M>, M extends Move>"

package Types << rectangle >> {

  package Standard << rectangle >>{
    $type(number)
    $type(string)
    $type(boolean)
  }

  package Aliases << rectangle >> {

    $type(Integer)
    Integer [alias] ..> number

    $type(Char)
    Char [alias] ..> string

  }

}

package move_package as "Move" {

  interface MoveParams {
    title: string
    description: string
  }

  abstract class Move {
    - title: MoveParams::title
    - description: MoveParams::description
    --
    + getTitle(): MoveParams::title
    + getDescription(): MoveParams::description
  }
  Move::title --> MoveParams::title
  Move::description --> MoveParams::description

  $type(MoveTuple, $M) {
    [Integer, M]
  }
  MoveTuple::0 --> Move

}

package game_package as "Game" {

  package Aliases << rectangle >> {

    $type(Player)
    Player [alias] ..> Integer

  }

  interface PlayerData {
    symbol: Char
    name: string
  }

  interface GameParams $M {
    name: string
    players: Map<Player, PlayerData>
    quantityOfSlots: Integer
    moves: Map<Integer, M>;
  }
  GameParams::players --> Player
  GameParams::players --> PlayerData
  GameParams::moves --> Move

  abstract class Game $M {
    - name: GameParams::name
    - players: GameParams::players
    # quantityOfSlots: GameParams::quantityOfSlots
    # moves: GameParams::moves
    --
    + getName(): GameParams::name
    + getPlayerData(player: Player): PlayerData
    + getPlayers(): GameParams::players
    + getQuantityOfSlots(): GameParams::quantityOfSlots
    + getMoves(): GameParams::moves
    .. abstract ..
    + {abstract} getInitialState(): State<this>
  }
  Game::name --> GameParams::name
  Game::players --> GameParams::players
  Game::quantityOfSlots --> GameParams::quantityOfSlots
  Game::moves --> GameParams::moves
  
}

package state_package as "State" {

  package Enums << rectangle >> {
    
    enum Pixel {
      Off = 0
      On = 1
    }

  }

  package Aliases << rectangle >> {

    $type(Channel)
    Channel [alias] ..> Integer

    $type(EncodedState) {
      Pixel[][][]
    }
    EncodedState::0 [alias] ..> Pixel

    $type(Points)
    Points [alias] ..> number

    $type(Position)
    Position [alias] ..> Integer

    $type(Slot)
    Slot [alias] ..> Integer

    $type(ValidMove)
    ValidMove [alias] ..> boolean

  }

  interface TurnOutcome {
    gameHasEnded: boolean
    winner: Player
    points: Map<Player, Points>
  }
  TurnOutcome::winner --> Player
  TurnOutcome::points --> Player
  TurnOutcome::points --> Points

  interface StateParams $G {
    game: G
    lastPlayer: Player | null
    lastPoints: Map<Player, Points>
    lastTakenMove: M | null
    slots: Slot[]
  }
  StateParams::game --> Game
  StateParams::lastPlayer --> Player
  StateParams::lastPoints --> Player
  StateParams::lastPoints --> Points
  StateParams::lastTakenMove --> Move
  StateParams::slots --> Slot

  abstract class State $G {
    # game: StateParams::game
    - slots: StateParams::slots
    ..
    # lastPlayer: StateParams::lastPlayer
    # lastPoints: StateParams::lastPoints
    # lastTakenMove: StateParams::lastTakenMove
    --
    + getGame(): StateParams::game
    + getLastPlayer(): StateParams::lastPlayer
    + getLastTakenMove(): StateParams::lastTakenMove
    + getSlots(): StateParams::slots
    + getSlotAt(position: Position): Slot
    + getMaskFromValidMoves(): boolean[]
    .. abstract ..
    + {abstract} getCurrentPlayer(): Player
    + {abstract} getEncodedState(): EncodedState
    + {abstract} getTurnOutcome(): TurnOutcome
    + {abstract} getValidMoves(): Map<Integer, M>
    + {abstract} getWinner(): Player | null
    + {abstract} changePerspective(player: Player): State<G>
    + {abstract} clone(): State<G>
    + {abstract} playMove(move: M): State<G>
    + {abstract} toString(): string
    .. static ..
    + {static} setSlotInEncodedState(rowIndex: Integer, columnIndex: Integer, channel: Channel, encodedState: EncodedState): void
  }
  State::game --> StateParams::game
  State::slots --> StateParams::slots
  State::lastPlayer --> StateParams::lastPlayer
  State::lastPoints --> StateParams::lastPoints
  State::lastTakenMove --> StateParams::lastTakenMove

}

package monte_carlo_tree_search_common_package as "Monte Carlo Tree Search Common" {

  interface NodeParams $G {
    state: State<G, M>
    explorationConstant: number
    parent: Node<G, M> | null
  }

  class Node $G {
    - state: NodeParams::state
    - explorationConstant: NodeParams::explorationConstant
    - parent: NodeParams::parent
    - children: Node<G, M>[]
    - maskFromExpandedMoves: boolean[]
    - initialPlayer: Player
    - quantityOfVisits: Integer
    - victoryQuality: Integer
    + getChildren(): Node<G, M>[]
    + getQuantityOfVisits(): Integer
    + getState(): State<G, M>
    + isFullyExpanded(): boolean
    + getChildUcb(child: Node<G, M>): number
    + selectBestChild(): Node<G, M>
    + pickRandomMove(): M
  }
  Node::state --> NodeParams::state
  Node::explorationConstant --> NodeParams::explorationConstant
  Node::parent --> NodeParams::parent

}

@enduml
