@startuml play
title Class diagram

hide empty members

!function $type($a)
!return "struct " + $a + " << (T,lavender) >>"
!endfunction

' package Enums{

'   enum Outcome {
'     Win = 1
'     Draw = 0
'     Loss = -1
'   }

' }

package Types << rectangle >> {

  package Standard << rectangle >>{
    $type(number)
    $type(string)
    $type(boolean)
  }

  package Aliases << rectangle >> {

    $type(Integer)
    Integer [alias] ..> number

    $type(Char)
    Char [alias] ..> string

  }

}

package state_package as "State" {

  package Enums{
    
    enum Pixel {
      Off = 0
      On = 1
    }

  }

  package Aliases <<rectangle >> {

    $type(Channel)
    Channel [alias] ..> Integer

    $type(Move) 
    Move [alias] ..> Integer

    $type(EncodedState) {
      Pixel[][][]
    }
    EncodedState::Pixel ..> Pixel

    $type(Player)
    Player [alias] ..> Integer

    $type(Points)
    Points [alias] ..> number

    $type(Position)
    Position [alias] ..> Integer

    $type(Slot)
    Slot [alias] ..> Integer

    $type(ValidMove)
    ValidMove [alias] ..> boolean

  }

  $type(TurnOutcome){
    gameHasEnded: boolean
    winner: Player
    points: Map<Player, Points>
  }
  TurnOutcome::winner --> Player
  TurnOutcome::points --> Player
  TurnOutcome::points --> Points

  $type("StateParams <G extends Game>"){
    game: G
    lastPlayer: Player | null
    lastTakenMove: Move | null
    lastPoints: Map<Player, Points>
    slots: Slot[]
  }
  StateParams::game --> Game
  StateParams::lastPlayer --> Player
  StateParams::lastTakenMove --> Move
  StateParams::lastPoints --> Player
  StateParams::lastPoints --> Points
  StateParams::slots --> Slot

  abstract class State

}

interface PlayerData{
  symbol: Char
  name: string
}

interface GameParams {
  name: string
  players: Map<Player, PlayerData>
}

abstract class Game {

}

@enduml